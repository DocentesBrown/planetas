<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pizarra Matem√°tica IA</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tesseract.js (OCR) -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js'></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Segoe UI', sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* Video oscuro para referencia visual */
        #input_video {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.1; /* Casi invisible, solo para referencia */
            z-index: 1;
        }

        /* Lienzo de dibujo */
        #draw_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
            transform: scaleX(-1);
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .result-box {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #00ffcc;
            color: #00ffcc;
            padding: 20px;
            border-radius: 15px;
            font-size: 2rem;
            text-align: center;
            min-width: 300px;
            align-self: center;
            margin-top: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
            backdrop-filter: blur(10px);
            transition: transform 0.2s;
        }

        .guide-panel {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 0.9rem;
        }

        .cursor {
            position: absolute;
            width: 20px; height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            pointer-events: none;
            display: none;
        }

        /* Animaci√≥n de carga */
        .scanning-line {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 4px;
            background: #00ffcc;
            box-shadow: 0 0 10px #00ffcc;
            animation: scan 2s linear infinite;
            display: none;
            z-index: 6;
        }

        @keyframes scan {
            0% { top: 0%; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }
    </style>
</head>
<body>

<div id="container">
    <div id="scanning-line" class="scanning-line"></div>
    <video id="input_video" playsinline></video>
    <canvas id="draw_canvas"></canvas>
    
    <!-- Cursor visual para saber d√≥nde est√° la mano -->
    <div id="hand-cursor" class="cursor"></div>

    <div id="ui-layer">
        <div id="result-display" class="result-box">
            <span class="text-sm block text-gray-400 mb-1">Resultado</span>
            <span id="math-output">--</span>
        </div>

        <div class="flex justify-between items-end">
            <div class="guide-panel">
                <p class="font-bold text-yellow-400 mb-1">Gestos:</p>
                <div class="flex items-center gap-2"><span>‚òùÔ∏è</span> √çndice: <span class="text-gray-300">Dibujar</span></div>
                <div class="flex items-center gap-2"><span>üñêÔ∏è</span> Palma: <span class="text-gray-300">Mover</span></div>
                <div class="flex items-center gap-2"><span>‚úä</span> Pu√±o: <span class="text-gray-300">Borrar</span></div>
                <div class="flex items-center gap-2"><span>üëç</span> Pulgar: <span class="text-gray-300">CALCULAR</span></div>
            </div>
            
            <div id="status-text" class="text-white bg-black bg-opacity-50 px-4 py-2 rounded-lg">
                Iniciando c√°mara...
            </div>
        </div>
    </div>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const drawCanvas = document.getElementById('draw_canvas');
    const ctx = drawCanvas.getContext('2d');
    const handCursor = document.getElementById('hand-cursor');
    const outputText = document.getElementById('math-output');
    const statusText = document.getElementById('status-text');
    const scanner = document.getElementById('scanning-line');
    const resultBox = document.getElementById('result-display');

    let isDrawing = false;
    let isCalculating = false;
    let lastX = 0, lastY = 0;
    let recognitionWorker = null;

    // Configuraci√≥n del Pincel
    ctx.lineWidth = 12; // L√≠nea gruesa para que la IA lea mejor
    ctx.lineCap = 'round';
    ctx.strokeStyle = '#ffffff'; // Blanco puro para alto contraste

    // --- 1. INICIALIZAR TESSERACT (OCR) ---
    async function initOCR() {
        statusText.innerText = "Cargando cerebro matem√°tico...";
        try {
            recognitionWorker = await Tesseract.createWorker();
            await recognitionWorker.loadLanguage('eng');
            await recognitionWorker.initialize('eng');
            // Restringir caracteres a n√∫meros y operadores para mejorar precisi√≥n
            await recognitionWorker.setParameters({
                tessedit_char_whitelist: '0123456789+-x*/=',
            });
            statusText.innerText = "Sistema listo. ¬°Dibuja!";
        } catch (e) {
            console.error(e);
            statusText.innerText = "Error cargando OCR. Revisa tu conexi√≥n.";
        }
    }

    // --- 2. L√ìGICA MATEM√ÅTICA ---
    async function performCalculation() {
        if (isCalculating) return;
        isCalculating = true;
        scanner.style.display = 'block';
        statusText.innerText = "Analizando pizarra...";
        
        // Efecto visual UI
        resultBox.style.transform = "scale(1.1)";
        setTimeout(() => resultBox.style.transform = "scale(1)", 200);

        try {
            // Convertir canvas a imagen
            // Importante: Tesseract lee mejor negro sobre blanco o blanco sobre negro muy claro.
            // Enviaremos el canvas tal cual (Blanco sobre transparente/negro)
            
            const { data: { text } } = await recognitionWorker.recognize(drawCanvas);
            
            console.log("Detectado:", text);
            
            // Limpiar texto (quitar espacios y caracteres extra√±os)
            let cleanText = text.replace(/[^0-9+\-*\/x]/g, '');
            // Reemplazar 'x' por '*'
            cleanText = cleanText.replace(/x/g, '*');

            if (cleanText.length > 0) {
                try {
                    // C√ÅLCULO SEGURO
                    // Usamos Function en vez de eval directo por seguridad m√≠nima, aunque en local es ok.
                    const result = new Function('return ' + cleanText)();
                    
                    // Mostrar
                    if (result !== undefined && !isNaN(result)) {
                        outputText.innerText = `${cleanText} = ${result}`;
                        statusText.innerText = "¬°C√°lculo completado!";
                    } else {
                        outputText.innerText = "?";
                        statusText.innerText = "No entend√≠ la cuenta.";
                    }
                } catch (mathErr) {
                    outputText.innerText = cleanText + " ?";
                    statusText.innerText = "Operaci√≥n inv√°lida.";
                }
            } else {
                statusText.innerText = "Pizarra vac√≠a o ilegible.";
            }

        } catch (err) {
            console.error(err);
            statusText.innerText = "Error al leer.";
        }

        isCalculating = false;
        scanner.style.display = 'none';
    }

    // --- 3. DETECCI√ìN DE GESTOS ---
    function detectGesture(landmarks) {
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        const wrist = landmarks[0];

        // Funci√≥n distancia
        const d = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        // A. PU√ëO (Todos los dedos cerrados) -> BORRAR
        const fingersClosed = d(indexTip, wrist) < 0.4 && d(middleTip, wrist) < 0.4 && d(ringTip, wrist) < 0.4;
        if (fingersClosed) return 'CLEAR';

        // B. PULGAR ARRIBA (Thumb Up) -> CALCULAR
        // El pulgar est√° lejos, pero los otros dedos cerrados
        if (d(thumbTip, wrist) > 0.4 && d(indexTip, wrist) < 0.4 && d(middleTip, wrist) < 0.4) {
            return 'CALCULATE';
        }

        // C. √çNDICE SOLO (Pointing) -> DIBUJAR
        if (d(indexTip, wrist) > 0.4 && d(middleTip, wrist) < 0.35 && d(ringTip, wrist) < 0.35) {
            return 'DRAW';
        }

        // D. MANO ABIERTA -> MOVER
        return 'HOVER';
    }

    // --- 4. MEDIAPIPE LOOP ---
    function onResults(results) {
        // Ajustar tama√±o canvas
        if (drawCanvas.width !== window.innerWidth) {
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;
            // Re-configurar pincel tras resize
            ctx.lineWidth = 12; 
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#ffffff';
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const gesture = detectGesture(landmarks);
            
            // Posici√≥n del dedo √≠ndice (revisar inversi√≥n X)
            // MediaPipe X va de 0 a 1.
            const x = landmarks[8].x * drawCanvas.width;
            const y = landmarks[8].y * drawCanvas.height;

            // Actualizar cursor visual
            handCursor.style.display = 'block';
            handCursor.style.left = ((1 - landmarks[8].x) * 100) + '%'; // Invertir visualmente para espejo
            handCursor.style.top = (landmarks[8].y * 100) + '%';

            // M√°quina de estados
            if (gesture === 'DRAW') {
                handCursor.style.borderColor = '#00ff00'; // Verde = Dibujando
                if (!isDrawing) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    isDrawing = true;
                } else {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
            } else if (gesture === 'CALCULATE') {
                handCursor.style.borderColor = '#ffff00'; // Amarillo = Calculando
                isDrawing = false;
                if (!isCalculating) performCalculation();
            } else if (gesture === 'CLEAR') {
                handCursor.style.borderColor = '#ff0000'; // Rojo = Borrando
                isDrawing = false;
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                outputText.innerText = "--";
            } else {
                handCursor.style.borderColor = '#ffffff'; // Blanco = Espera
                isDrawing = false;
                ctx.beginPath();
            }

        } else {
            handCursor.style.display = 'none';
            isDrawing = false;
        }
    }

    // --- 5. CONFIGURACI√ìN INICIAL ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    window.onload = () => {
        initOCR(); // Iniciar motor de lectura
        camera.start();
    };

</script>
</body>
</html>
