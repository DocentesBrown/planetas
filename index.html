<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dibujo Espacial & Tierra 3D</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* Video de fondo (espejo) */
        #input_video {
            position: absolute;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
            opacity: 0.5; /* Un poco oscuro para que resalte el dibujo */
        }

        /* Capa 3D (Tierra) */
        #three_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* Capa de Dibujo 2D */
        #draw_canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 3;
            transform: scaleX(-1); /* Espejo para coincidir con video */
            pointer-events: none;
        }

        /* UI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
        }

        .hud-panel {
            background: rgba(0, 0, 0, 0.7);
            border-left: 4px solid #00aaff;
            padding: 15px;
            color: white;
            max-width: 350px;
            border-radius: 0 10px 10px 0;
            backdrop-filter: blur(4px);
        }

        .mode-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 5px;
            transition: all 0.3s;
        }
        .mode-rotate { background: #00aaff; color: white; box-shadow: 0 0 10px #00aaff; }
        .mode-draw { background: #ff00ff; color: white; box-shadow: 0 0 10px #ff00ff; }
        .mode-clear { background: #ff3333; color: white; }
        .mode-idle { background: #555; color: #ccc; }

        .loader {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00aaff;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid #00aaff;
            z-index: 50;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="draw_canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel mt-4">
            <h1 class="text-2xl font-bold mb-1 text-cyan-300">Estudio Espacial</h1>
            <div id="status-badge" class="mode-badge mode-idle">Esperando c√°mara...</div>
            <div class="mt-4 text-sm space-y-2 text-gray-300">
                <div class="flex items-center">
                    <span class="text-xl w-8">üñêÔ∏è</span>
                    <span><strong>Mano Abierta:</strong> Rotar Tierra</span>
                </div>
                <div class="flex items-center">
                    <span class="text-xl w-8">‚òùÔ∏è</span>
                    <span><strong>Dedo √çndice:</strong> Dibujar Luz</span>
                </div>
                <div class="flex items-center">
                    <span class="text-xl w-8">‚úä</span>
                    <span><strong>Pu√±o Cerrado:</strong> Borrar Todo</span>
                </div>
            </div>
        </div>
        
        <div class="text-right text-xs text-gray-400 mb-2">
            Usa buena iluminaci√≥n para mejor detecci√≥n
        </div>
    </div>

    <div id="loading-screen" class="loader">
        <h2 class="text-2xl font-bold mb-2">Iniciando Sistemas</h2>
        <p class="animate-pulse">Cargando IA y Modelos 3D...</p>
        <p class="text-xs mt-4 text-gray-500">Por favor permite el acceso a la c√°mara.</p>
    </div>
</div>

<script>
    // --- ELEMENTOS ---
    const videoElement = document.getElementById('input_video');
    const threeCanvas = document.getElementById('three_canvas');
    const drawCanvas = document.getElementById('draw_canvas');
    const ctx = drawCanvas.getContext('2d');
    const statusBadge = document.getElementById('status-badge');
    const loadingScreen = document.getElementById('loading-screen');

    // --- VARIABLES DE ESTADO ---
    let width, height;
    let isDrawing = false;
    let lastX = 0, lastY = 0;
    let hue = 0; // Color del arco√≠ris

    // Three.js Vars
    let scene, camera, renderer, earth, clouds;
    let targetRotX = 0, targetRotY = 0;
    let currentRotX = 0, currentRotY = 0;

    // --- INICIALIZACI√ìN THREE.JS (TIERRA) ---
    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 6;

        renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;

        // Texturas
        const loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous'; // IMPORTANTE

        const earthGeo = new THREE.SphereGeometry(1.5, 64, 64);
        const earthMat = new THREE.MeshPhongMaterial({
            map: loader.load('https://upload.wikimedia.org/wikipedia/commons/c/c1/Earth_Day_2026_Color_Image.jpg'),
            bumpMap: loader.load('https://upload.wikimedia.org/wikipedia/commons/c/c3/Solarsystemscope_texture_2k_earth_normal_map.png'),
            bumpScale: 0.05,
            specularMap: loader.load('https://upload.wikimedia.org/wikipedia/commons/1/15/Solarsystemscope_texture_2k_earth_specular_map.png'),
            specular: new THREE.Color('grey')
        });
        earth = new THREE.Mesh(earthGeo, earthMat);
        scene.add(earth);

        const cloudGeo = new THREE.SphereGeometry(1.53, 64, 64);
        const cloudMat = new THREE.MeshLambertMaterial({
            map: loader.load('https://upload.wikimedia.org/wikipedia/commons/0/07/Solarsystemscope_texture_2k_earth_clouds.jpg'),
            transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
        });
        clouds = new THREE.Mesh(cloudGeo, cloudMat);
        scene.add(clouds);

        // Luces
        scene.add(new THREE.AmbientLight(0x333333));
        const sun = new THREE.DirectionalLight(0xffffff, 1.5);
        sun.position.set(5, 3, 5);
        scene.add(sun);
        const rim = new THREE.SpotLight(0x00aaff, 2);
        rim.position.set(-5, 0, 2);
        rim.lookAt(earth.position);
        scene.add(rim);

        animateThree();
    }

    function animateThree() {
        requestAnimationFrame(animateThree);
        
        // Lerp para suavidad
        currentRotX += (targetRotX - currentRotX) * 0.1;
        currentRotY += (targetRotY - currentRotY) * 0.1;

        if(earth) {
            earth.rotation.y = currentRotY;
            earth.rotation.x = currentRotX;
            clouds.rotation.y = currentRotY + Date.now() * 0.0001;
            clouds.rotation.x = currentRotX;
        }
        renderer.render(scene, camera);
    }

    // --- L√ìGICA DE DIBUJO Y GESTOS ---
    function detectGesture(landmarks) {
        // Puntos clave
        const indexTip = landmarks[8];
        const indexDip = landmarks[7]; // Nudillo superior
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        const thumbTip = landmarks[4];

        // L√≥gica simple de dedos levantados (Y menor es m√°s arriba en pantalla)
        // Pero usamos la distancia relativa al nudillo para ser m√°s precisos independientemente de la rotaci√≥n
        // Simplificaci√≥n: Un dedo est√° "abajo" si su punta est√° m√°s abajo que su nudillo base en coordenadas locales
        // Usaremos una heur√≠stica simple basada en Y para "pu√±o vs mano abierta"
        
        // 1. Detectar PU√ëO (Todos los dedos cerrados cerca de la palma)
        // Comprobar si las puntas est√°n cerca de la base de la palma (landmark 0)
        const isFist = (
            dist(indexTip, landmarks[0]) < 0.3 &&
            dist(middleTip, landmarks[0]) < 0.3 &&
            dist(ringTip, landmarks[0]) < 0.3
        );

        if (isFist) return 'CLEAR';

        // 2. Detectar "SOLO INDICE" (Pointing)
        // El √≠ndice est√° extendido, los otros (medio, anular, me√±ique) est√°n cerrados
        const indexExtended = dist(indexTip, landmarks[0]) > 0.4; // √çndice lejos de la palma
        const othersClosed = (
            dist(middleTip, landmarks[0]) < 0.35 &&
            dist(ringTip, landmarks[0]) < 0.35
        );

        if (indexExtended && othersClosed) return 'DRAW';

        // 3. Detectar MANO ABIERTA (Todos extendidos)
        if (dist(middleTip, landmarks[0]) > 0.4 && dist(ringTip, landmarks[0]) > 0.4) {
            return 'ROTATE';
        }

        return 'IDLE';
    }

    function dist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    function onResults(results) {
        loadingScreen.style.display = 'none';
        
        // Ajustar tama√±o canvas dibujo si cambia ventana
        if (drawCanvas.width !== window.innerWidth) {
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const gesture = detectGesture(landmarks);
            
            // Coordenadas dedo √≠ndice para dibujar/rotar
            // MediaPipe: x: 0-1, y: 0-1.
            const x = landmarks[8].x * drawCanvas.width;
            const y = landmarks[8].y * drawCanvas.height;

            if (gesture === 'DRAW') {
                statusBadge.innerText = "Modo: PINCEL C√ìSMICO";
                statusBadge.className = "mode-badge mode-draw";
                
                // Dibujar
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                hue = (hue + 2) % 360; // Ciclo de colores arco√≠ris

                // Efecto de brillo
                ctx.shadowBlur = 15;
                ctx.shadowColor = ctx.strokeStyle;

                if (!isDrawing) {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    isDrawing = true;
                } else {
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
                lastX = x;
                lastY = y;

            } else if (gesture === 'ROTATE') {
                statusBadge.innerText = "Modo: CONTROL TIERRA";
                statusBadge.className = "mode-badge mode-rotate";
                isDrawing = false;
                ctx.beginPath(); // Resetear path

                // Controlar Tierra (Invertimos X para efecto espejo natural)
                // Centro pantalla (0.5) -> rotaci√≥n 0
                targetRotY = (landmarks[8].x - 0.5) * -4;
                targetRotX = (landmarks[8].y - 0.5) * 4;

            } else if (gesture === 'CLEAR') {
                statusBadge.innerText = "Modo: BORRANDO...";
                statusBadge.className = "mode-badge mode-clear";
                isDrawing = false;
                
                // Borrar canvas
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                
            } else {
                statusBadge.innerText = "Modo: ESPERA";
                statusBadge.className = "mode-badge mode-idle";
                isDrawing = false;
                ctx.beginPath();
            }

            // Dibujar cursor auxiliar peque√±o siempre para saber d√≥nde est√° el dedo
            /*
            ctx.save();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            */

        } else {
            statusBadge.innerText = "No veo tu mano...";
            statusBadge.className = "mode-badge mode-idle";
            isDrawing = false;
        }
    }

    // --- SETUP MEDIAPIPE ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    // --- SETUP CAMARA ---
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    // --- INICIO ---
    window.onload = () => {
        initThree();
        cameraUtils.start().catch(e => {
            console.error(e);
            loadingScreen.innerHTML = "<h2 class='text-red-500'>Error de C√°mara</h2><p>Verifica permisos</p>";
        });
    };

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        drawCanvas.width = window.innerWidth;
        drawCanvas.height = window.innerHeight;
    });

</script>
</body>
</html>
